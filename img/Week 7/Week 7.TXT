I started with understand the basics of all the components. Next was to understand the pinout diagram of ATtiny 44.
The datasheet seemed alien to me and I had to shift to a different source to understand. But before that I had to understand
what a microcontroller(MCU) is and how it works. It is esentially as computer with a CPU, a memory, a system clock and few peripherals.
It is meant to perform specific tasks and find extensive application in embedded systems. Arduino is a great example of a MCU. 
One can find MCU in cameras, microwave ovens and many other household electronics. 
 https://www.youtube.com/watch?v=CmvUY4S0UbI

For someone like me who is not from an electronics background, understanding pinouts from datasheet initially was a nightmare and 
I religiously dedicated some time to understand it using various resoruces.  
I found a page on github that illustrates the pinout in a better way. 
https://github.com/SpenceKonde/ATTinyCore/blob/master/avr/extras/ATtiny_x4.md

First Things First, there are pins and there are ports. A Pin is the physical metal part coming from the chip and 
the number ascribed to it given its location on that chip. A Port refers to a Pin given its function within a register or the ports 
are the I/O input/output channel connected internally to those pins. Furthermore, a
register could be understood here (https://home.roboticlab.eu/en/avr/registers). 

Next up, one would see an array of names labelled in a sequence expanding both 
sides of the microcontroller pins. This is an alternative pinout diagram of the microcontroller(here ATtiny 44). To make it more
clear, lets take pin 13, its labelled as PA0, PCINT0, 0/A0, 10/A0, AREF and ADC0. This means that Pin 13 can be used as Port A 0(PA0),
Pin Change Interrupt 0 (PCINT0),  Analog Reference (AREF) and Analog to Digital Converter (ADC0). One thing to mention here is that 
Pin 13 is always Pin 13 but also Port 0 in the PA register. 





What is MISO, MOSI....?
As I was going through the Pinout diagram of the ATtiny 44, I came across MISO, MOSI, SCK alien terms and had to again look on the 
internet, what these things mean. So a microcontroller uses Serial Peripheral Interface (SPI), a synchronous serial data protocol
used by microcontrollers for communicating with one or more peripheral devices quickly over short distances. It can also be used 
for communication between two microcontrollers. With an SPI connection(Using a 2x3 pin header and connector) there is always one
master device (usually a microcontroller) which controls the peripheral devices.
    MISO (Master In Slave Out) - The Slave line for sending data to the master,
    MOSI (Master Out Slave In) - The Master line for sending data to the peripherals,
    SCK (Serial Clock) - The clock pulses which synchronize data transmission generated by the master 
Three other lines that are present are VCC, GND and RESET or RST. 
The SPI connection is also used to programme a programmer from a microcontroller. 
One can also find MISO, MOSI, SCK, VCC, GND and RESET/RST on ATtiny 44 pinout diagram at pins 8, 7, 9, 1, 14 and 4. 
This link provides details in simple language :https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi/all


Echo Hello Board Redesigning

I chose Eagle over other softwares to design my PCB board because I had earlier(Week 5) tried using some basic features of the software
and found its UI to be very friendly. https://www.autodesk.com/products/eagle/free-download.
Next up, Fab network has created a library for EAGLE consisting of components commonly used in PCB design during the Fab Academy course.
1. Download the Fab library for Eagle here.
2. Place the downloaded fab.lbr file in C:\Users\Vaibhav\AppData\Roaming\Eagle\lbr. I created a folder named Fab in lbr folder and placed the fab.lbr file there.
3. Once you start EAGLE you will automatically see the fab.lbr in the control panel on the left side along with other predefined libraries.
4. To get going initially, I downloaded the 
5. Next up, I went into the Project directory of Eagle and created a new folder named Fab and inside that another folder named Hello World, to 
keep the structure clean and keep my files for this assignment. 
6. By right clicking on the folder "hello world", I create a new project and a new Schematic.
7. A schematic window opens up where we can draw the circuits without worrying about the component placement.
8. I started by adding a frame so that my circuit looks neat. This is done by either typing add or in the left tab, look for AddPart.
This will open a new window with the library and you can go to frames and choose the one you like depending on the size of your circuit.
9. One important tip while searching for components in the library. Use suffix *(wildcard on multiple characters) and ?(wildcard on
 single character)
10. rcl library is highly used library in Eagle. 

The basic components of the echo hello world board are:

 ATTiny 44 as MCU x1
 6 Pin AVR ISP Header x1
 FTDI Header x1
 20 MHz Resonator x1
 1 uF Capacitor x1
 10K Ohm Resistor x1

and I further added the following:

0K Ohm Resistor x1
Switch x1



The reset button resets the whole IC, it is by default in active high state. You can attach a switch button to reset it manually to active low state. 

11. To make connections between the components, I extended a line from the individual components using NETS and then typed the same unique name between
various components to join them. If one wants one can also label them. 
12. Since I had a bad experience about how to know whether the PCB board is receiving power or not, hence I added one LED as soon the as the board received power.
13. Now I wanted to play around a bit with input output hence charlieplexing (http://fab.academany.org/2018/labs/barcelona/students/nicolo-gnecchi/output-devices/)
14. Before moving forward, an important step is to check whether all pins are connected or not. One might get some errors if some pins are unused, these can be ignored.
15. Next go to file and the click Switch to board, this opens up the board view in new window, here you can set the trace width and clearance, to name a few. The yellow
lines display unrouted traces.
16. Select and move the components into the window.
17 The way to solve routing is:
   a)First solve the LED array grid.
   b)Then fix the ATtiny 44.
   c)Create GND such that it can connect components both inside as well as outside.
   d)Do the same for VCC.
   e) A golden tip would be use autorouter when you have placed around 70% of your components. It will give you clues how to rearrange the components.

18. I made some major mistakes during routing the connections between LEDs of the the array. I forgot 4 series connections between the LEDs and due to shortage of time,
had to make an alternative by 

19. Finally a rule of thumb, the thickness of the traces should be 0.016 inch, this is neither too much nor too less. Also, keep the distance between two traces 0.016
inch. I used 1/64 inch on SRM-20 to mill my board and it came out pretty good. 


Programming

1. My board can run both hello echo(http://academy.cba.mit.edu/classes/embedded_programming/index.html#echo) as well as hello array(http://academy.cba.mit.edu/classes/output_devices/index.html)(from week 13).
 Hence, I downloaded the "C" and "make" file for both from the individual weeks.
They could be found here.
2. Since I am using windows, I will use Git Bash to execute the commands and test my board. (http://academy.cba.mit.edu/classes/embedded_programming/hello.ftdi.44.program.png)
3. I opened GitBash from the same folder where I had saved C and make files. 
4. Execute, make -f hello.ftdi.44.echo.c.make, to compile the programme.
5. Execute, make -f hello.ftdi.44.echo.c.make program-usbtiny-fuses, to set the fuses. You should see avrdude done. Thank you. at the end.
6. Execute, make -f hello.ftdi.44.echo.c.make program-usbtiny, this will flash the programme to the IC. 

Now to run hello array follow the same steps above except that I renamed the file to hello.array.44.2.c.make
7. Execute, make -f hello.array.44.2.c.make, , to compile the programme.
8. Execute, make -f hello.array.44.2.c.make program-usbtiny-fuses
9. Execute, make -f hello.array.44.2.c.make program-usbtiny, this will flash the programme to the IC. 







	



