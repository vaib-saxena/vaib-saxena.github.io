# Generic AVR Makefile - Adapted for FabTinyStar
# Brian Mayton <bmayton@media.mit.edu>
#
# 'make' builds the .hex file.
# 'make flash' uses the programmer to load it onto the target chip.
# 'make fuses' programs the fuse bits on the target chip.
# 'make rstdisbl' blows the reset fuse.
# 'make clean' removes all autogenerated files.

# OBJECTS should list all of the object files for the program (e.g. for each
# .c file, list a corresponding .o file here.)  APPLICATION just specifies the
# name of the hex/elf files, and can be whatever you want. 
OBJECTS = main.o usbdrv/usbdrv.o usbdrv/oddebug.o usbdrv/usbdrvasm.o
APPLICATION = fts_firmware

# Set up which MCU you're using, and what programmer, and the clock speed
# here.
MCU = attiny45
PROGRAMMER ?= usbtiny
F_CPU = 16500000UL

# Fuse bit settings
EFUSE=0xFF
HFUSE=0xDD
LFUSE=0xE1

# Fuse bit settings with reset pin disabled
HFUSE_RSTDISBL=0x5D

# Edit these if you want to use different compilers
CC = avr-gcc
OBJCOPY = avr-objcopy
SIZE = avr-size
AVRDUDE = avrdude

# Compiler and linker flags
CFLAGS=-mmcu=$(MCU) -Wall -DF_CPU=$(F_CPU) -I. -funsigned-char \
	-funsigned-bitfields -fpack-struct -fshort-enums -Os -Iusbdrv
LDFLAGS=-mmcu=$(MCU)

all: $(APPLICATION).hex

clean:
	rm -f usbdrv/*.o
	rm -f *.hex *.elf *.o 

%.hex: %.elf
	$(OBJCOPY) -j .text -j .data -O ihex $< $@

$(APPLICATION).elf: $(OBJECTS)
	$(CC) $(LDFLAGS) -o $@ $^
	$(SIZE) -C --mcu=$(MCU) $@

%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

%.o: %.S
	$(CC) -x assembler-with-cpp $(CFLAGS) -c $< -o $@

flash: all
	$(AVRDUDE) -p $(MCU) -c $(PROGRAMMER) -P usb -e \
		-U flash:w:$(APPLICATION).hex

fuses:
	$(AVRDUDE) -p $(MCU) -c $(PROGRAMMER) -P usb \
		-U lfuse:w:$(LFUSE):m -U hfuse:w:$(HFUSE):m \
		-U efuse:w:$(EFUSE):m

rstdisbl:
	$(AVRDUDE) -p $(MCU) -c $(PROGRAMMER) -P usb \
		-U lfuse:w:$(LFUSE):m -U hfuse:w:$(HFUSE_RSTDISBL):m \
		-U efuse:w:$(EFUSE):m

.PHONY: all clean install fuses

